# 10. Interactividad avanzada

## Gestión del estado en streamlit

En el contexto del desarrollo web, las cookies de estado son un método común utilizado para la gestión de estados. Las cookies son pequeños fragmentos de datos almacenados en la computadora del usuario. Son como notas de memoria que la aplicación puede leer y escribir para recordar cosas sobre la sesión del usuario.

Por ejemplo, cuando inicia sesión en un sitio web, lo mantiene conectado incluso cuando cierra el navegador. Si bien Streamlit no utiliza cookies en el sentido tradicional como en el desarrollo web habitual, proporciona una funcionalidad similar a través de su gestión de estados de sesión.

El siguiente fragmento de código es un ejemplo simple de gestión de estados en Streamlit, que crea un contador que aumenta con cada pulsación de botón:

```python
import streamlit as st

# Initialize state
if 'conteo' not in st.session_state:
    st.session_state.conteo = 0

# Increment function
def incrementa_contador():
    st.session_state.conteo += 1

# Botón que invcrementa el conteo
st.button('Incrementa el conteo', on_click=incrementa_contador)
# Texto que muestra el estado
st.write('Conteo: ', st.session_state.conteo)
```

En este ejemplo, `st.session_state` actúa como memoria, recordando el recuento de pulsaciones de botones en las repeticiones de la aplicación. Esto es similar a cómo funcionan las cookies en las aplicaciones web tradicionales, haciendo un seguimiento de las interacciones y los estados del usuario.

El estado de sesión de Streamlit es un espacio de memoria especial donde su aplicación puede recordar cosas. Por ejemplo, si un usuario escribe algo o hace clic en un botón, `session_state` se puede utilizar para almacenar estos valores. Puede almacenar cualquier tipo de objeto Python, como números enteros, números de punto flotante, números complejos y booleanos, DataFrames e incluso lambdas devueltos por funciones. Pero en algunos casos, especialmente cuando está ejecutando su aplicación en diferentes entornos, como en diferentes computadoras o servidores, debe asegurarse de que todo lo que coloque en esta memoria se pueda almacenar y recuperar de forma segura.

Ahí es donde entra en juego **Serializable Session State**. Streamlit tiene una configuración (`runner.enforceSerializableSessionState`) que, cuando se activa, se asegura de que solo almacene cosas en el Session State que se puedan “envasar” y “desenvasar” de forma segura.

Es como garantizar que todo lo que almacenas en la memoria se pueda guardar de forma segura en una caja y conservar o eliminar sin problemas. Para utilizar esta configuración, puedes agregarla a un archivo de configuración para tu proyecto Streamlit o usar un comando al ejecutar tu aplicación. Esto ayuda a garantizar que tu aplicación funcione sin problemas, especialmente cuando se ejecuta en diferentes lugares o si planeas cambiar la forma en que ejecutas tu aplicación. El siguiente es el fragmento para configurar el estado de la sesión serializable en config.toml:

```toml
# ~/.streamlit/config.toml
[runner]
enforceSerializableSessionState = true
```

Existen ciertas limitaciones dignas de mención al trabajar con un estado de sesión Streamlit. Los siguientes son los puntos clave a recordar al usar el estado de sesión:

- En un formulario Streamlit, solo el botón de envío (`st.form_submit_button`) puede tener una función callback (de devolución de llamada).

```python
import streamlit as st

# Inicializar el estado de sesión si no existe
if 'form_data' not in st.session_state:
    st.session_state.form_data = {
        'name': '',
        'age': 0,
        'email': ''
    }

# Función para manejar el envío del formulario
def handle_form_submit():
    st.session_state.form_data['name'] = st.session_state.name
    st.session_state.form_data['age'] = st.session_state.age
    st.session_state.form_data['email'] = st.session_state.email
    st.success("Formulario enviado correctamente!")

# Crear el formulario
with st.form("my_form"):
    st.write("Por favor, complete el formulario:")
    
    # Campos de entrada
    st.session_state.name = st.text_input("Nombre", 
                                value=st.session_state.form_data['name'])
    st.session_state.age = st.number_input("Edad", min_value=0, 
                                max_value=120, 
                                value=st.session_state.form_data['age'])
    st.session_state.email = st.text_input("Email", 
                                value=st.session_state.form_data['email'])
    
    # Botón de envío
    submitted = st.form_submit_button("Enviar", on_click=handle_form_submit)

# Mostrar los datos del formulario guardados en el estado de sesión
if any(st.session_state.form_data.values()):
    st.write("Datos del formulario guardados:")
    st.write(f"Nombre: {st.session_state.form_data['name']}")
    st.write(f"Edad: {st.session_state.form_data['age']}")
    st.write(f"Email: {st.session_state.form_data['email']}")

# Nota: los text_input y el number_input no tienen callback.
```

- Las opciones de manejo de eventos como `on_change` y `on_click` solo son compatibles con widgets de entrada, como `st.text_input`, `st.button`:

    ```python
    import streamlit as st
    # on_change event in a text input widget
    def handle_text_change():
        st.write("Text has changed")
    
    st.text_input("Change the text", on_change=handle_text_change)
    # on_click event in a button widget
    st.button("Click me", on_click=lambda: st.write("Button clicked"))
    ```

- Una vez que crea un widget, no puede modificar su valor a través de la API de estado de sesión. Intentar hacerlo dará como resultado una StreamlitAPIException. La siguiente es la aplicación Streamlit de muestra cuando el estado de sesión se implementa incorrectamente:

    ```python
    import streamlit as st
    # Creating a text input widget
    text = st.text_input(key="text_input", label = "Enter text")
    # Incorrect way: Attempting to modify the widget value after creation
    st.session_state.text_input = "New Value"
    # This will raise StreamlitAPIException
    ```

- No se recomienda establecer el estado de un widget utilizando tanto la API de estado de sesión como el parámetro de valor del widget simultáneamente. Hacerlo activará una advertencia en la primera ejecución.

    ```python
    import streamlit as st
    # Incorrect way: Setting state via Session State API and value parameter
    st.session_state.text_input = "New Value"
    # Creating a text input widget
    text = st.text_input(key="text_input", 
                         label = "Enter text" , 
                         value = st.session_state.text_input)
    ```

- No puede establecer el estado de los widgets similares a botones (`st.button`, `st.download_button` y `st.file_uploader`) a través de la API de estado de sesión. Generará una excepción. Estos widgets tienen un estado predeterminado de Falso y un estado Verdadero temporal que es válido solo para la ejecución actual.

    ```python
    import streamlit as st
    # Incorrect way: Attempting to set the state of a button
    st.session_state.my_button = True
    # Not allowed
    # Using a button
    if st.button("Click me", key = 'my_button'):
        st.write("Button was clicked!")
    ```

## Uso de la caché para optimizar el rendimiento y el tiempo de carga

### ¿Por qué es importante el caching en Streamlit?

Streamlit ejecuta el script completo cada vez que el usuario interactúa con la aplicación. Sin caching, esto podría resultar en operaciones redundantes y costosas que ralentizan la aplicación. El caching permite reutilizar resultados previamente calculados, lo que mejora significativamente el rendimiento y la experiencia del usuario.

En Streamlit, el uso de `@st.cache_data` y `@st.cache_resource` es fundamental para mejorar el rendimiento de las aplicaciones, especialmente cuando se trabaja con operaciones costosas en términos de tiempo o recursos, como la carga de datos o la inicialización de modelos de machine learning.

### `@st.cache_data`

Este decorador se utiliza para cachear los resultados de funciones que cargan o procesan datos. Al cachear estos resultados, evitas que la función se ejecute nuevamente si los parámetros de entrada no han cambiado, lo que acelera la ejecución de la aplicación.

- **`ttl` (Time To Live)**: Especifica el tiempo en segundos que los datos deben permanecer en la caché antes de ser eliminados. Esto es útil para datos que pueden cambiar con el tiempo, como datos de una API que se actualiza periódicamente.
- **`show_spinner`**: Si se establece en `True`, muestra un spinner en la interfaz de usuario mientras se cargan o procesan los datos. Esto mejora la experiencia del usuario al indicar que la aplicación está trabajando.
- **`max_entries`**: Limita el número de entradas en la caché. Si se supera este límite, las entradas más antiguas se eliminan para hacer espacio a las nuevas.
- **`hash_function`**: Permite especificar una función personalizada para generar un hash de los argumentos de la función. Esto es útil si los argumentos no son directamente hashables o si quieres controlar cómo se comparan los argumentos para determinar si la función debe volver a ejecutarse.

Ejemplo:

```python
@st.cache_data(ttl=3600, show_spinner=True, max_entries=10)
def load_data(url):
    data = pd.read_csv(url)
    return data

```

### `@st.cache_resource`

Este decorador es similar a `@st.cache_data`, pero está diseñado para cachear recursos que deben estar disponibles globalmente en la aplicación, como conexiones a bases de datos, modelos de machine learning, o cualquier otro recurso que sea costoso de inicializar.

- **`ttl`**: Igual que en `@st.cache_data`, especifica el tiempo en segundos que el recurso debe permanecer en la caché.
- **`show_spinner`**: Muestra un spinner mientras se inicializa el recurso.
- **`max_entries`**: Limita el número de recursos en la caché.
- **`hash_function`**: Permite especificar una función personalizada para generar un hash de los argumentos.

Ejemplo:

```python
@st.cache_resource(ttl=3600, show_spinner=True)
def load_model():
    model = torch.load('model.pth')
    return model
```

### Diferencias clave entre `@st.cache_data` y `@st.cache_resource`

- **`@st.cache_data`**: Se utiliza para cachear datos que son el resultado de una función. Estos datos se almacenan en memoria y se invalidan si los parámetros de la función cambian.
- **`@st.cache_resource`**: Se utiliza para cachear recursos que deben ser compartidos y reutilizados en toda la aplicación, como conexiones a bases de datos o modelos de machine learning. Estos recursos no se invalidan tan fácilmente y están diseñados para ser persistentes.

> En versiones anteriores de Streamlit existía el decorador `@st.cache`, pero a partir de **Streamlit 1.18.0**, este fue **deprecado** (obsoleto) y reemplazado por dos decoradores más específicos y optimizados: `@st.cache_data` y `@st.cache_resource`. No estaba claro si el decorador debía usarse para cachear datos (como DataFrames) o recursos (como conexiones a bases de datos o modelos). Esto podía llevar a errores o malas prácticas.
>

- Manejo de la interacción entre widgets y visualizaciones
- Callbacks (devolución de llamada) (225)

    ```python
    import streamlit as st
    # Define the callback function
    def toggle_message():
        if 'show_message' not in st.session_state:
            st.session_state.show_message = False
            st.session_state.show_message = not st.session_state.show_message
    
    # Create a button and associate the callback
    st.button("Toggle Message", on_click=toggle_message)
    
    # Conditional display based on the callback's effect on session state
    if st.session_state.get('show_message', False):
        st.write("Hello, Streamlit!")
    ```

    Streamlit también admite interacciones complejas, como la actualización dinámica de contenido en función del envío de formularios.
    El siguiente ejemplo muestra cómo usar un formulario con una devolución de llamada para actualizar el estado de la aplicación en función de la entrada del usuario:

    ```python
    import streamlit as st
    # Callback to process form submission
    def process_form():
        user_name = st.session_state.user_name
        user_age = st.session_state.user_age
    
    st.write(f"Name: {user_name}, Age: {user_age}")
    
    # Define a form with inputs and a submit button
    with st.form("user_form", clear_on_submit=True):
        st.text_input("Enter your name", key="user_name")
        st.number_input("Enter your age", min_value=0, max_value=100, step=1, key="user_age")
        submit_button = st.form_submit_button("Submit", on_click=process_form)
    ```

    Las mejores prácticas que se deben tener en cuenta al usar devoluciones de llamadas son las siguientes:

    Use el estado de la sesión con criterio: aproveche el estado de la sesión para administrar el estado de la aplicación en las devoluciones de llamadas, pero tenga en cuenta su alcance y ciclo de vida.

    Mantenga las devoluciones de llamadas livianas: dado que las devoluciones de llamadas se pueden activar con frecuencia, asegúrese de que funcionen de manera eficiente para mantener una experiencia de usuario receptiva.

    Depuración: utilice `st.write(st.session_state)` para depurar y comprender cómo cambia el estado de la sesión con las interacciones del usuario.
