# 10. Interactividad avanzada con el estado

## Gesti√≥n del estado en streamlit

En el contexto del desarrollo web, las cookies de estado son un m√©todo com√∫n utilizado para la gesti√≥n de estados. Las cookies son peque√±os fragmentos de datos almacenados en la computadora del usuario. Son como notas de memoria que la aplicaci√≥n puede leer y escribir para recordar cosas sobre la sesi√≥n del usuario.

Por ejemplo, cuando inicia sesi√≥n en un sitio web, lo mantiene conectado incluso cuando cierra el navegador. Si bien Streamlit no utiliza cookies en el sentido tradicional como en el desarrollo web habitual, proporciona una funcionalidad similar a trav√©s de su gesti√≥n de estados de sesi√≥n.

El siguiente fragmento de c√≥digo es un ejemplo simple de gesti√≥n de estados en Streamlit, que crea un contador que aumenta con cada pulsaci√≥n de bot√≥n:

```python
# Archivo estado_0.py
import streamlit as st

# Inicializar el estado de sesi√≥n si no existe
if 'conteo' not in st.session_state:
    st.session_state.conteo = 0

# Funci√≥n para incrementar el contador
def incrementa_contador():
    st.session_state.conteo += 1

# Bot√≥n que invcrementa el conteo
st.button('Incrementa el conteo', on_click=incrementa_contador)

# Texto que muestra el estado
st.write('Conteo: ', st.session_state.conteo)
```

En este ejemplo, `st.session_state` act√∫a como memoria, recordando el recuento de pulsaciones de botones en las repeticiones de la aplicaci√≥n. Esto es similar a c√≥mo funcionan las cookies en las aplicaciones web tradicionales, haciendo un seguimiento de las interacciones y los estados del usuario.

El estado de sesi√≥n de Streamlit es un espacio de memoria especial donde su aplicaci√≥n puede recordar cosas. Por ejemplo, si un usuario escribe algo o hace clic en un bot√≥n, `session_state` se puede utilizar para almacenar estos valores. Puede almacenar cualquier tipo de objeto Python, como n√∫meros enteros, n√∫meros de punto flotante, n√∫meros complejos y booleanos, DataFrames e incluso lambdas devueltos por funciones.

>üëâ
>En algunos casos, especialmente cuando se est√° ejecutando la aplicaci√≥n en diferentes entornos, como en diferentes computadoras o servidores, hay que asegurarse de que todo lo que se coloque en esta memoria se pueda almacenar y recuperar de forma segura.
>
>Ah√≠ es donde entra en juego **Serializable Session State**. Streamlit tiene una configuraci√≥n (`runner.enforceSerializableSessionState`) que, cuando se activa, se asegura de que solo almacene cosas en el Session State que se puedan ‚Äúenvasar‚Äù y ‚Äúdesenvasar‚Äù de forma segura.
>
>Es como garantizar que todo lo que almacenas en la memoria se pueda guardar de forma segura en una caja y conservar o eliminar sin problemas. Para utilizar esta configuraci√≥n, puedes agregarla a un archivo de configuraci√≥n para tu proyecto Streamlit o usar un comando al ejecutar tu aplicaci√≥n. Esto ayuda a garantizar que la aplicaci√≥n funcione sin problemas, especialmente cuando se ejecuta en diferentes lugares o si planeas cambiar la forma en que ejecutas tu aplicaci√≥n. El siguiente es el fragmento para configurar el estado de la sesi√≥n serializable en config.toml:
>
>```toml
># ~/.streamlit/config.toml
>[runner]
>enforceSerializableSessionState = true
>```

### Limitaciones del estado de sesi√≥n

Existen ciertas limitaciones dignas de menci√≥n al trabajar con un estado de sesi√≥n Streamlit. Los siguientes son los puntos clave a recordar al usar el estado de sesi√≥n:

- En un formulario Streamlit, solo el bot√≥n de env√≠o (`st.form_submit_button`) puede tener una funci√≥n callback (de devoluci√≥n de llamada).

    ```python
    # Archivo estado_1.py
    import streamlit as st
    
    # Inicializar el estado de sesi√≥n si no existe
    if 'form_data' not in st.session_state:
        st.session_state.form_data = {
            'name': '',
            'age': 0,
            'email': ''
        }
    
    # Funci√≥n para manejar el env√≠o del formulario
    def handle_form_submit():
        st.session_state.form_data['name'] = st.session_state.name
        st.session_state.form_data['age'] = st.session_state.age
        st.session_state.form_data['email'] = st.session_state.email
        st.success("Formulario enviado correctamente!")
    
    # Crear el formulario
    with st.form("my_form"):
        st.write("Por favor, complete el formulario:")
        
        # Campos de entrada
        input_name = st.text_input("Nombre", 
                                    value=st.session_state.form_data['name'],
                                    key='name')
        input_age = st.number_input("Edad", min_value=0, 
                                    max_value=120, 
                                    value=st.session_state.form_data['age'],
                                    key='age')
        input_email = st.text_input("Email", 
                                    value=st.session_state.form_data['email'],
                                    key='email')
        
        # Bot√≥n de env√≠o
        submitted = st.form_submit_button("Enviar", on_click=handle_form_submit)
    
    # Mostrar los datos del formulario guardados en el estado de sesi√≥n
    if any(st.session_state.form_data.values()):
        st.write("Datos del formulario guardados:")
        st.write(f"Nombre: {st.session_state.form_data['name']}")
        st.write(f"Edad: {st.session_state.form_data['age']}")
        st.write(f"Email: {st.session_state.form_data['email']}")
        st.divider()
        st.write("Datos de la sesi√≥n:")
        st.write(st.session_state)
    
    # Nota: los text_input y el number_input no tienen callback.
    ```

- Las opciones de manejo de eventos como `on_change` y `on_click` solo son compatibles con widgets de entrada, como `st.text_input`, `st.button`:

    ```python
    # Archivo estado_2.py
    import streamlit as st
    # Evento on_change en un text_input
    def handle_text_change():
        st.write("Text has changed")
    
    st.text_input("Change the text", on_change=handle_text_change)
    # Evento on_click en un button
    st.button("Click me", on_click=lambda: st.write("Button clicked"))
    ```

- Una vez que crea un widget, no puede modificar su valor a trav√©s de la API de estado de sesi√≥n. Intentar hacerlo dar√° como resultado una StreamlitAPIException. La siguiente es la aplicaci√≥n Streamlit de muestra cuando el estado de sesi√≥n se implementa incorrectamente:

    ```python
    # Archivo estado_3.py
    import streamlit as st
    
    # Crear un input de texto
    text = st.text_input(key="input_texto", label = "Introduzca un texto aqu√≠")
    # Ya no se puede modificar el valor del widget despu√©s de su creaci√≥n
    
    st.session_state.input_texto = "New Value"
    # Generar√° una excepci√≥n StreamlitAPIException
    ```

- No se recomienda establecer el estado de un widget utilizando tanto la API de estado de sesi√≥n como el par√°metro de valor del widget simult√°neamente. Hacerlo activar√° una advertencia en la primera ejecuci√≥n.

    ```python
    # Archivo estado_4.py
    import streamlit as st
    
    # Forma incorrecta: Establecer el estado a trav√©s de la API de Session State y el par√°metro value
    st.session_state.text_input = "New Value"
    
    text = st.text_input(key="text_input", 
                         label = "Enter text" , 
                         value = st.session_state.text_input)
    ```

- No puede establecer el estado de los widgets similares a botones (`st.button`, `st.download_button` y `st.file_uploader`) a trav√©s de la API de estado de sesi√≥n. Generar√° una excepci√≥n. Estos widgets tienen un estado predeterminado de Falso y un estado Verdadero temporal que es v√°lido solo para la ejecuci√≥n actual.

    ```python
    # Archivo estado_5.py
    import streamlit as st
    # Forma incorrecta: Establecer el estado de un button despu√©s de su creaci√≥n
    st.session_state.my_button = True
    
    if st.button("Click me", key = 'my_button'):
        st.write("Button was clicked!")
    ```
